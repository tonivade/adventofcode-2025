; https://adventofcode.com/2025/day/4

(import java.lang.String lines)
(import java.lang.String split 1)
(import java.lang.Integer parseInt 1)

(load-file "mal/aoc.mal")

(defn right [point] (list (incr (first point)) (second point)))
(defn left [point] (list (decr (first point)) (second point)))
(defn up [point] (list (first point) (incr (second point))))
(defn down [point] (list (first point) (decr (second point))))
(defn right-up [point] (list (incr (first point)) (incr (second point))))
(defn right-down [point] (list (incr (first point)) (decr (second point))))
(defn left-up [point] (list (decr (first point)) (incr (second point))))
(defn left-down [point] (list (decr (first point)) (decr (second point))))

(defn adjacent [point]
    (map to-key
        (list
            (right point)
            (left point)
            (up point)
            (down point)
            (right-up point)
            (right-down point)
            (left-up point)
            (left-down point)
        )
    )
)

(defn to-pair [k] (map parseInt (split (str k) ",")))
(defn to-key [p] (str (first p) "," (second p)))

(defn count-paper [point matrix]
    (let* (points (adjacent point))
        (count
            (filter
                (fn* [k]
                    (and (contains? matrix k) (= (get matrix k) "@"))
                )
                points
            )
        )
    )
)

(defn removable [matrix]
    (filter
        (fn* [p] (< (count-paper (to-pair p) matrix) 4))
        (filter (fn* [k] (= (get matrix k) "@")) (keys matrix))
    )
)

(defn remove-all [matrix to-remove]
    (if (empty? to-remove)
        matrix
        (remove-all (dissoc matrix (first to-remove)) (rest to-remove))
    )
)

(defn step [matrix acc]
    (let* (to-remove (removable matrix))
        (if (empty? to-remove)
            acc
            (step (remove-all matrix to-remove) (+ acc (count to-remove)))
        )
    )
)

(defn parse [file]
    (let* (input (slurp file))
        (list-to-map
            (flatten
                (map
                    (fn* [row]
                        (map
                            (fn* [cell]
                                (list (to-key (list (second row) (second cell))) (first cell))
                            )
                            (first row)
                        )
                    )
                    (zip-with-index (map zip-with-index (map seq (lines input))))
                )
            )
        )
    )
)

(def! input (if-defined DEBUG-EVAL "input/day4-test.txt" "input/day4.txt"))

(println (timed! (count (removable (parse input)))))

(println (timed! (step (parse input) 0)))

;; utility methods

(load-file "mal/basic.mal")

(defn second [xs] (nth xs 1))
(defn abs [n] (if (>= n 0) n (* n -1)))
(defn incr [n] (+ n 1))
(defn decr [n] (- n 1))
(defn peek [i] (do (println i) i))

(defn join [xs]
    (if (empty? xs)
        ""
        (str (first xs) (join (rest xs)))
    )
)

(defn zip-list [l r]
    (if (or (empty? l) (empty? r))
        (list)
        (cons (list (first l) (first r)) (zip-list (rest l) (rest r)))
    )
)

(defn zip-with-index [xs]
    (let* (go (fn* [xs i]
              (if (empty? xs)
                  ()
                  (cons (list (first xs) i)
                        (go (rest xs) (incr i))))))
        (go xs 0)
    )
)

(defn take [xs i]
    (if (empty? xs)
        xs
        (if (> i 0)
            (cons (first xs) (take (rest xs) (decr i)))
            (list)
        )
    )
)

(defn drop [xs i]
    (if (empty? xs)
        xs
        (if (> i 0)
            (drop (rest xs) (decr i))
            xs
        )
    )
)

(defn for-all? [cmp xs]
    (if (empty? xs)
        true
        (and (cmp (first xs)) (for-all? cmp (rest xs)))
    )
)

(defn exists? [cmp xs]
    (if (empty? xs)
        false
        (or (cmp (first xs)) (exists? cmp (rest xs)))
    )
)

(defn filter [cmp xs]
    (if (empty? xs)
        xs
        (if (cmp (first xs))
            (cons (first xs) (filter cmp (rest xs)))
            (filter cmp (rest xs))
        )
    )
)

(defn insert-sort-by [cmp item xs] 
    (if (or (empty? xs) (cmp item (first xs)))
        (cons item xs) 
        (cons (first xs) (insert-sort-by cmp item (rest xs)))
    )
)

(defn sort-list-by [cmp xs] 
    (if (empty? xs) 
        xs 
        (insert-sort-by cmp (first xs) (sort-list-by cmp (rest xs)))
    )
)

(defn sort-list [xs] 
    (sort-list-by (fn* [a b] (< a b)) xs)
)

(defn reduce [initial func xs] 
    (if (empty? xs) 
        initial 
        (reduce (func (first xs) initial) func (rest xs))
    )
)

(defn flatten [xs] (reduce (list) concat xs))
(defn sum [xs] (reduce 0 + xs))
(defn mul [xs] (reduce 1 * xs))
(defn max [xs] (reduce 0 (fn* [i j] (if (> i j) i j)) xs))

(defn chunks [xs size]
    (if (or (= size 0) (empty? xs))
        (list)
        (let* (group (take xs size) rst (drop xs size))
            (cons group (chunks rst size))
        )
    )
)

(defn timed [func]
    (let* (start (time-ms) result (func) end (time-ms))
        (do
            (println "Elapsed time:" (- end start) "ms")
            result
        )
    )
)

(defmacro! timed! 
    (fn* (& body) 
        `(timed (fn* [] ~@body))
    )
)

(defn generate [start end]
    (if (> start end)
        (list)
        (cons start (generate (incr start) end))
    )
)

(defn last [xs] 
    (let* (pos (decr (count xs)))
        (nth xs pos)
    )
)

(defn drop-last [xs] 
    (if (or (empty? xs) (empty? (rest xs)))
        ()
        (cons (first xs) (drop-last (rest xs)))
    )
)

(defn append [xs item] (concat xs (list item)))

(defn list-to-map [xs]
    (reduce 
        {}
        (fn* [pair m] (assoc m (first pair) (second pair)))
        xs
    )
)

(defn replace-nth [xs n val]
    (if (empty? xs)
        ()
        (if (= n 0)
            (cons val (rest xs))               ; replace head
            (cons (first xs)                   ; keep head, recurse
                (replace-nth (rest xs) (decr n) val))
        )
    )
)

(defn index-where [xs cmp]
    (let* (go (fn* (xs cmp i)
              (if (empty? xs)
                  nil
                  (if (cmp (first xs))
                      i
                      (go (rest xs) cmp (incr i))))))
        (go xs cmp 0)
    )
)

(defn foreach [xs func]
    (if (empty? xs)
        nil
        (do
            (func (first xs))
            (foreach (rest xs) func)
        )
    )
)

(defn group-by [func xs]
    (reduce
        {}
        (fn* [item acc]
            (let* (k (str (func item)))
                (if (contains? acc k)
                    (assoc acc k (cons (first item) (get acc k)))
                    (assoc acc k (list (first item)))
                )
            )
        )
        xs
    )
)

(defn sliding2 [xs]
    (if (or (empty? xs) (empty? (rest xs)))
        ()
        (cons 
            (list (first xs) (first (rest xs))) 
            (sliding2 (rest xs))
        )
    )
)

(defn reverse [xs]
    (let* (go (fn* (l acc)
              (if (empty? l)
                  acc
                  (go (rest l) (cons (first l) acc)))))
        (go xs ())
    )
)
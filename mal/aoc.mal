;; utility methods

(load-file "mal/basic.mal")

(defn second [l] (nth l 1))
(defn abs [n] (if (>= n 0) n (* n -1)))
(defn incr [n] (+ n 1))
(defn decr [n] (- n 1))
(defn peek [i] (do (println i) i))

(defn join [xs]
    (if (empty? xs)
        ""
        (str (first xs) (join (rest xs)))
    )
)

(defn zip-list [l r]
    (if (or (empty? l) (empty? r))
        (list)
        (cons (list (first l) (first r)) (zip-list (rest l) (rest r)))
    )
)

(defn zip-with-index [l]
  (let* (go (fn* [l i]
              (if (empty? l)
                  ()
                  (cons (list (first l) i)
                        (go (rest l) (incr i))))))
    (go l 0)))

(defn take [l i]
    (if (empty? l)
        l
        (if (> i 0)
            (cons (first l) (take (rest l) (decr i)))
            (list)
        )
    )
)

(defn drop [l i]
    (if (empty? l)
        l
        (if (> i 0)
            (drop (rest l) (decr i))
            l
        )
    )
)

(defn for-all? [c l]
    (if (empty? l)
        true
        (and (c (first l)) (for-all? c (rest l)))
    )
)

(defn exists? [c l]
    (if (empty? l)
        false
        (or (c (first l)) (exists? c (rest l)))
    )
)

(defn filter [c l]
    (if (empty? l)
        l
        (if (c (first l))
            (cons (first l) (filter c (rest l)))
            (filter c (rest l))
        )
    )
)

(defn insert-sort-by [c item l] 
    (if (or (empty? l) (c item (first l)))
        (cons item l) 
        (cons (first l) (insert-sort-by c item (rest l)))
    )
)

(defn sort-list-by [c l] 
    (if (empty? l) 
        l 
        (insert-sort-by c (first l) (sort-list-by c (rest l)))
    )
)

(defn sort-list [l] 
    (sort-list-by (fn* [a b] (< a b)) l)
)

(defn reduce [z f l] 
    (if (empty? l) 
        z 
        (f (first l) (reduce z f (rest l)))
    )
)

(defn fold [z f l] 
    (if (empty? l) 
        z 
        (fold (f z (first l)) f (rest l))
    )
)

(defn flatten [l] (reduce (list) concat l))
(defn sum [l] (reduce 0 + l))
(defn mul [l] (reduce 1 * l))
(defn max [l] (reduce 0 (fn* [i j] (if (> i j) i j)) l))

(defn chunks [lst size]
    (if (or (= size 0) (empty? lst))
        (list)
        (let* (group (take lst size) rst (drop lst size))
            (cons group (chunks rst size))
        )
    )
)

(defn timed [f]
    (let* (start (time-ms) result (f) end (time-ms))
        (do
            (println "Elapsed time:" (- end start) "ms")
            result
        )
    )
)

(defmacro! timed! 
    (fn* (& body) 
        `(timed (fn* [] ~@body))
    )
)

(defn generate [start end]
    (if (> start end)
        (list)
        (cons start (generate (incr start) end))
    )
)

(defn reverse [lst]
    (if (empty? lst)
        ()
        (concat (reverse (rest lst)) (list (first lst)))
    )
)

(defn list-to-map [lst]
    (reduce 
        {}
        (fn* [pair m] (assoc m (first pair) (second pair)))
        lst
    )
)

(defn replace-nth [lst n val]
    (if (empty? lst)
        ()
        (if (= n 0)
            (cons val (rest lst))               ; replace head
            (cons (first lst)                   ; keep head, recurse
                (replace-nth (rest lst) (decr n) val))
        )
    )
)

(defn index-where [lst c]
    (let* (go (fn* (lst c i)
              (if (empty? lst)
                  nil
                  (if (c (first lst))
                      i
                      (go (rest lst) c (incr i))))))
        (go lst c 0)
    )
)

(defn foreach [lst f]
    (if (empty? lst)
        nil
        (do
            (f (first lst))
            (foreach (rest lst) f)
        )
    )
)

(defn group-by [f lst]
    (reduce
        {}
        (fn* [item acc]
            (let* (k (str (f item)))
                (if (contains? acc k)
                    (assoc acc k (cons (first item) (get acc k)))
                    (assoc acc k (list (first item)))
                )
            )
        )
        lst
    )
)